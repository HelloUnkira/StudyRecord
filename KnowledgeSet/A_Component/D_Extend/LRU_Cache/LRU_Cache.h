#ifndef LRU_CACHE_H
#define LRU_CACHE_H
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
#define "DoubleList.h"
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
typedef enum LeastRecentlyUsed_Status {
    LRU_Status_Default  = 0,
    LRU_Status_IError,      /* 模组出现内部错误,已崩溃 */
    LRU_Status_MemFail,     /* 设备当前内存不足 */
    LRU_Status_Overflow,    /* 获取的资源超出缓存单元门限 */
    LRU_Status_NotFind,     /* 要释放的资源不在缓存中 */
    LRU_Status_Hit,         /* 缓存命中 */
    LRU_Status_UnHit,       /* 缓存未命中 */
} LRU_Status;
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
typedef int32_t (*EA_Read)(uint8_t *EAddr, uint32_t *IAddr, uint32_t Length);
typedef int32_t (*EA_Write)(uint8_t *EAddr, uint32_t *IAddr, uint32_t Length);
typedef void  * (*IA_Alloc)(uint32_t Length);
typedef void    (*IA_Free)(void *Pointer);
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
typedef struct LeastRecentlyUsed_Control {
    EA_Read  Read;  /* 到外存读取指定逻辑地址的读函数回调钩子 */
    EA_Write Write; /* 回写到外存指定逻辑地址的写函数回调钩子 */
    IA_Alloc Alloc; /* 内存申请函数回调钩子 */
    IA_Free  Free;  /* 内存释放函数回调钩子 */
    DL_List  List;
    uint32_t Usage; /* 缓存对内存资源占用情况 */
    uint32_t Unit;  /* 缓存对内存资源使用单元门限 */
    uint32_t Sum;   /* 缓存对内存资源占用总门限 */
} LRU_Control;
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
static inline void LRU_Cache_Reset(LRU_Control *Control, uint32_t Unit, uint32_t Sum,
                                   EA_Read Read, EA_Write Write, IA_Alloc Alloc, IA_Free Free)
{
    Control->Read  = Read;      /* 外存读回调函数 */
    Control->Write = Write;     /* 外存写回调函数 */
    Control->Alloc = Alloc;     /* 内存分配函数 */
    Control->Free  = Free;      /* 内存释放函数 */
    Control->Usage = 0;         /* 内存资源占用(超出总门限时缓存会对其做清理) */
    Control->Unit  = Unit;      /* 单元资源门限(超出该限制时,资源的释放和索取将跳过缓存) */
    Control->Sum   = Sum;       /* 内存资源总占用门限 */
    DL_List_Reset(&(Control->List));
}
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/

/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
#endif

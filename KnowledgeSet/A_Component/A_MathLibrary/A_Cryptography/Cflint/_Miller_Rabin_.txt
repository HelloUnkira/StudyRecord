Miller和Rabin两个人的工作让Fermat素性测试迈出了革命性的一步
建立了传说中的Miller-Rabin素性测试算法

定理1:
If P Is Prime
When
    1.  0 < X < P 
    2.  X^2 mod P == 1          // 平方差公式
Then
    1.  X == 1
        X == P - 1

定理2:
//伪素数定理
//通过该表达式验证的素数不一定是素数
X^(P-1) Mod P = 1


素性测试:
    P - 1 == D * 2 ** K
    测试 X ^ (P - 1) Mod P ?= 1               通过后继续,不通过则为合数
    测试 X ^ (D * 2** (K - 1)) Mod P ?= 1     通过后继续,不通过则为合数
    测试 X ^ (D * 2** (K - 2)) Mod P ?= 1     通过后继续,不通过则为合数
    测试 ...                                  通过后继续,不通过则为合数
    测试 X ^ (D * 2** (K)) Mod P ?= 1 Or P - 1    
    
    
    
素性测试流程:
    1.生成一个随机大整数X (如果是偶数则直接+-1)
        (如果指定范围[Start, End]则使用该范围)
        (如果未指定范围则随机生成指定长度的大整数)
    2.初级素性检测
        使用X个小素数执行检测流程(对模求余是否为0)
    3.高级素性检测
        使用Y个小素数执行Miller_Rabin测试
            (小素数数量决定筛选次数,也即精准度)
    
    途中失败统一返回第一步

    其中:
    该算法需要额外接收俩个素数表:
    第一个素数表用于初级素性检测  (小素数)
    第二个素数表用于高级素性检测  (小素数)

    uint32_t SizerLength1  = 50;    //轮数决定了当次筛选的强度
    uint32_t SizerTable1[] = {
          3,   5,   7,  11,  13,  17,  19,  23,  29,  31,
         37,  41,  43,  47,  53,  59,  61,  67,  71,  73,
         79,  83,  89,  97, 101, 103, 107, 109, 113, 127,
        131, 137, 139, 149, 151, 157, 163, 167, 173, 179,
        181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
    };
    
    /* 可直接选用上述表的前几项(为了简单方便的话) */
    uint32_t SizerLength1  = 10;    //轮数决定了当次筛选的强度
    uint32_t SizerTable2[] = SizerTable1;
    

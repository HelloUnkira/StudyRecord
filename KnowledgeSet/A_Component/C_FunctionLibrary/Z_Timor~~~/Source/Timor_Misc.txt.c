/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo1>
 * 实现栈可满足入栈出栈
 * 查询栈中最大最小元素值的时间复杂度为O(1)
 * 分析:
 *     typedef struct {
 *        Stack   Node;
 *        int32_t Cur_Value;
 *        int32_t Min_Value;
 *        int32_t Max_Value;
 *     } DataStruct;
 *     在Push前,读取栈顶元素值,然后通过当前节点Cur
 *     和栈顶元素的Min和Max对比设置当前节点的Min和Max
 *     然后就可以执行Push操作
 *     而Pop操作无需改变
 */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo2>
 * 查找最小的k个数(时间复杂度为O(N))
 * 使用优先堆,构建一个为K的最大堆
 * 每次将最大元素与新元素比较,从而选择是否加入到堆中
 */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo3>
 * 俩个单链表相交
 * 分析:
 *     链表相交,从交点起之后一定是公用部分,因为单链表不能分叉
 *     所以,对于俩个链表,如果相交的话,短链表一定是长链表的子部分
 *     所以,先计算链表的节点,长链表跳过多余短链表的节点,使它们长度一致
 *     然后每个节点依次比较即可
 */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo4>
 * 镜像转换二元查找树
 * 分析:
 *     后序遍历递归即可,先镜像左右字树,然后交换左右字树的指针
 */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo5>
 * 就地逆序链表:
 * 分析:
 *     1.旧链表节点头部移出,头部插入到新链表
 *     2.递归逆序链表,先逆序后面子链表, 再逆序最前一个节点(需要带头尾节点辅助逆序)
 */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo6>
 * 求一个数组的最长递减子序列
 * 分析:
 *     动态规划,转移公式为:DP[I] = 1;
 *              DP[I] = DP[J] + 1 When J < I && Arr[J] >= Arr[I] && DP[J] + 1 > DP[I]
 */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/

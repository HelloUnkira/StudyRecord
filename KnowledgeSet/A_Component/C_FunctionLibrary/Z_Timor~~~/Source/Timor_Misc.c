/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
#include <stddef.h>
#include <stdint.h>
#include <stdbool.h>
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo>
 */
/* Timor_Misc:<Timo>Start */
/* Timor_Misc:<Timo>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
#include "..\Library\Stack.h"
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo1>
 * 二叉查找树到双向链表的转换
 * 分析1(非本地修改):
 *     typedef struct {
 *         RBT_Node T_Node; //使用该成员构建树,然后迭代树
 *         DL_Node  D_Node; //在迭代树的过程构建双向链表
 *         int32_t  Key;
 *         uint32_t Data;
 *         // ......
 *     } DataStruct;
 * 分析2(本地修改):
 *     直接分治思想解决即可(递归的解决)
 */
/* Timor_Misc:<Timo1>Start */

typedef struct {
    void *Prev_Left;    //表示树-左节点，表示链表-上一节点
    void *Next_Right;   //表示树-右节点，表示链表-下一节点
    int32_t KeyData;
} Timor_Misc_1_Node;

/* 构建,接收一个已排序数组,构建树 */
Timor_Misc_1_Node * Timor_Misc_1_CreateTree(int32_t *List, uint32_t Left, uint32_t Right)
{
    if (Left > Right)
        return NULL;
    if (Left == Right) {
        Timor_Misc_1_Node* Node = malloc(sizeof(Timor_Misc_1_Node));
        Node->KeyData    = List[Left];
        Node->Prev_Left  = NULL;
        Node->Next_Right = NULL;
        return Node;
    }
    
    uint32_t Center = (Left + Right) / 2;
    Timor_Misc_1_Node* Node = malloc(sizeof(Timor_Misc_1_Node));
    Node->KeyData    = List[Center];
    Node->Prev_Left  = Timor_Misc_1_CreateTree(List, Left,       Center - 1);
    Node->Next_Right = Timor_Misc_1_CreateTree(List, Center + 1, Right);
    return Node;
}

static void Timor_Misc_1_ToListRecursion(Timor_Misc_1_Node *Node)
{
    /* 直接以递归的方式实现即可,最简单精简 */
    if (Node->Prev_Left == NULL && Node->Next_Right == NULL)
        return;
    /* 处理左子树,将其转化成双向链表 */
    if (Node->Prev_Left != NULL) {
        /* 递归的将左子树转化成双向链表 */
        Timor_Misc_1_ToListRecursion(Node->Prev_Left);
        /* 迭代到左子树双向链表的最后一个节点,这是前驱 */
        Timor_Misc_1_Node *Prev = Node->Prev_Left;
        while (Prev->Next_Right != NULL)
            Prev = Prev->Next_Right;
        /* 关联这个前驱 */
        Prev->Next_Right = Node;
        Node->Prev_Left  = Prev;
    }
    /* 处理右子树,将其转化成双向链表 */
    if (Node->Next_Right != NULL) {
        /* 递归的将右子树转化成双向链表 */
        Timor_Misc_1_ToListRecursion(Node->Next_Right);
        /* 迭代到左子树双向链表的最前一个节点,这是后继 */
        Timor_Misc_1_Node *Next = Node->Next_Right;
        while (Next->Prev_Left != NULL)
            Next = Next->Prev_Left;
        /* 关联这个后继 */
        Next->Prev_Left  = Node;
        Node->Next_Right = Next;
    }
}

Timor_Misc_1_Node * Timor_Misc_1_ToList(Timor_Misc_1_Node *Root)
{
    Timor_Misc_1_ToListRecursion(Root);
    /* 迭代到最开始 */
    while (Root->Prev_Left != NULL)
        Root = Root->Prev_Left;
    return Root;
}

/* Timor_Misc:<Timo1>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo2>
 * 实现栈可满足入栈出栈
 * 查询栈中最大最小元素值的时间复杂度为O(1)
 * 分析:
 *     typedef struct {
 *        Stack   Node;
 *        int32_t Cur_Value;
 *        int32_t Min_Value;
 *        int32_t Max_Value;
 *     } DataStruct;
 *     在Push前,读取栈顶元素值,然后通过当前节点Cur
 *     和栈顶元素的Min和Max对比设置当前节点的Min和Max
 *     然后就可以执行Push操作
 *     而Pop操作无需改变
 */
/* Timor_Misc:<Timo2>Start */
/* Timor_Misc:<Timo2>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo3>
 * 数组的子数组最大和(时间复杂度为O(N))
 */
/* Timor_Misc:<Timo3>Start */

int32_t Timor_Misc_3_SubArrayMaxSum(int32_t *List, uint32_t Number)
{
    int32_t  MaxVal = 0, SumVal = 0;
    uint32_t MaxPos = 0, SumPos = 0; //起始点(结束点通过累加偏移算)
    for (uint32_t Index = 0; Index < Number; Index++) {
        if ((SumVal += List[Index]) < List[Index]) {
             SumVal  = List[Index];
             SumPos  = Index;
        }
        if (MaxVal < SumVal) {
            MaxVal = SumVal;
            MaxPos = SumPos;
        }
    }
    return MaxVal; //MaxPos
}

/* Timor_Misc:<Timo3>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo4>
 * 查找最小的k个数(时间复杂度为O(N))
 * 使用优先堆,构建一个为K的最大堆
 * 每次将最大元素与新元素比较,从而选择是否加入到堆中
 */
/* Timor_Misc:<Timo4>Start */
/* Timor_Misc:<Timo4>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo5>
 * 俩个单链表相交
 * 分析:
 *     链表相交,从交点起之后一定是公用部分,因为单链表不能分叉
 *     所以,对于俩个链表,如果相交的话,短链表一定是长链表的子部分
 *     所以,先计算链表的节点,长链表跳过多余短链表的节点,使它们长度一致
 *     然后每个节点依次比较即可
 */
/* Timor_Misc:<Timo5>Start */
/* Timor_Misc:<Timo5>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo7>
 * 位运算和函数实现1~N的和
 */
/* Timor_Misc:<Timo7>Start */

uint32_t Timor_Misc_7_SumBitAB(uint32_t Ci, uint32_t A, uint32_t B, uint32_t N)
{
    if (N >= 32)
        return 0;
    
    uint32_t Ai = A & (1 << N);
    uint32_t Bi = B & (1 << N);
    uint32_t Si = Ai ^ Bi ^ Ci;
    uint32_t Cp = ((Ai & Bi) | (Bi & Ci) | (Ai & Ci)) << 1;
    
    return Timor_Misc_7_SumBitAB(Cp, A, B, N + 1) | Si;
}

uint32_t Timor_Misc_7_SumAB(uint32_t A, uint32_t B)
{
    return Timor_Misc_7_SumBitAB(0, A, B, 0);
}

uint32_t Timor_Misc_7_SumN(uint32_t N)
{
    if (N <= 1)
        return 1;
    return Timor_Misc_7_SumAB(N, Timor_Misc_7_SumN(N - 1));
}

/* Timor_Misc:<Timo7>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo8>
 * 镜像转换二元查找树
 * 分析:
 *     后序遍历递归即可,先镜像左右字树,然后交换左右字树的指针
 */
/* Timor_Misc:<Timo8>Start */
/* Timor_Misc:<Timo8>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo9>
 * 输入俩个整数N,M,在[1,N]为范围求和为M全部数据集合
 * 分析:
 *     使用0-1背包分配,从最大开始
 *     F(N,M)可分为N是否被载入而分为F(N-1, M)与F(N-1, M-N)
 */
/* Timor_Misc:<Timo9>Start */

void Timor_Misc_9_Sum(int32_t N, uint32_t M, bool *Flag, int32_t Num)
{
    if (N < 1 || M < 1)
        return;
    if (N > M) //任何>m的数据没有求和组
        N = M;
    if (N == M) {
        Flag[N] = true;
        printf("\nCatch:\t");
        for (int32_t Index = 1; Index <= Num; Index++)
            if (Flag[Index])
                printf("%d ", Index);
        Flag[N] = false;
    }
    Flag[N] = true;
    Timor_Misc_9_Sum(N - 1, M - N, Flag, Num);
    Flag[N] = false;
    Timor_Misc_9_Sum(N - 1, M, Flag, Num);
}

void Timor_Misc_9_SumUnion(int32_t N, uint32_t M)
{
    bool *Flag = malloc(sizeof(bool) * (N + 1));
    for (int32_t Index = 0; Index < N + 1; Flag[Index] = false, Index++);
    Timor_Misc_9_Sum(N, M, Flag, N);
    free(Flag);
}

/* Timor_Misc:<Timo9>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo10>
 * 就地逆序链表:
 * 分析:
 *     1.旧链表节点头部移出,头部插入到新链表
 *     2.递归逆序链表,先逆序后面子链表, 再逆序最前一个节点(需要带头尾节点辅助逆序)
 */
/* Timor_Misc:<Timo10>Start */
/* Timor_Misc:<Timo10>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/
/* Timor_Misc:<Timo11>
 */
/* Timor_Misc:<Timo11>Start */
/* Timor_Misc:<Timo11>End */
/*************************************************************************************************/
/*************************************************************************************************/
/*************************************************************************************************/




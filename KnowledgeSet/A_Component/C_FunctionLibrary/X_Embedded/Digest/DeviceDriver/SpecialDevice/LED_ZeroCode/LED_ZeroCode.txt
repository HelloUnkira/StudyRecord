/*************************************************************************************************/
/* ReturnToZeroCodeTimming */
/*************************************************************************************************/
/* 归零码时序(摘要): */

/* 一般俩个码元间会有一定的低电平时间间隔,归零码指的是高电平起始到结束的时间 */

/*简介:
 *归零码时序主要有ns以及us级时序俩类
 *根据其对应的情况,选择不同的策略选取外设
 *并完成对应的编码
 */

/* 编码流程:  */

/* 调制归零码1码的时序: */
static inline void ReturnToZeroCode_ModulateHigh(void)
{
    /* 如例:使用SPI,配置好分频到20MHz时(一个周期100ns),MOSI输出:0xFE00,0x0000 */
    /*     (在配置高字节先发,高位先发的情况下): */
}
 
/* 调制归零码0码的时序: */
static inline void ReturnToZeroCode_ModulateLow(void)
{
    /* 如例:使用SPI,配置好分频到20MHz时(一个周期100ns),MOSI输出:0xE000,0x0000 */
    /*     (在配置高字节先发,高位先发的情况下): */
}
 
/* 调制归零码复位码的时序: */
static inline void ReturnToZeroCode_ModulateReset(void)
{
    /* 可简单使用循环反复发送0x0 */
}
 
/* 嵌入式外设抽象通用的实现接口举例: */
struct DriverFunctionSet {
    void (*Init)(void);
    void (*DeInit)(void);
    void (*Open)(void);
    void (*Close)(void);
    void (*Read)(void);
    void (*Write)(void);
};
 
/* 注意事项:
 * 归零码时序本身是精密且严格的时序,对时序的要求以及数据关联性的要求是极为严格的
 * 但对总线的占用时间占比整个周期内是很短的
 * 低功耗策略:仅仅在write或read前open外设和引脚复用,结束后立刻close,如果流程执行频繁,可适当对其 
 *           放宽
 */
/* 可能导致的偶现BUG:
 * 1.被驱动目标接收数据时序异常,逻辑分析仪或示波器采样数据不对,中间产生大量的高或低电平时序:
 *   可能的情况:1.多线程调度器对当前线程的影响;2.中断响应对时序的影响
 *   解决方案:添加临界区保护(因为归零码时序应用场景下,对时间要求虽然严格但持续时间不长
 *                         它在CPU中的驻留时间是非常短的,所以可以使用此方案)
 * 2.数据后面的数据位丢失:
 *   某些外设接口仅仅阻塞FIFO满事件,不关注数据是否全部发送完毕,在执行close的时候可能FIFO仍然堆积 
 *   着时序位未及时发送:
 *   解决方案:利用HAL的特定接口改为全阻塞模式,没有HAL可使用轮询查寄存器的方式
 */
/* 外设选取规则: */

/* ns级时序(例:TC3838RGB灯,1204幻彩RGB灯):
 * 首选:SPI,IIC
 * 次选:GPIO(关中断,可能可行,取决于对GPIO操作时的额外时间占用)
 * 备选:TIM+PWM+DMA+GPIO(仅全硬件托管才可行,流程中间不可执行软件流程干预)
 */

/* us级时序(例:DS18B20温度传感器):
 * 首选:TIM+NVIC
 * 次选:GPIO+Delay
 * 备选:SPI,IIC
 */

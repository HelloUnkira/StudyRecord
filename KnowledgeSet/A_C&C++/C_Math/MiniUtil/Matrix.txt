/* 离散数学:矩阵 */
typedef struct DiscreteMathMatrixBody {
    double **Element;   /* 矩阵实体 */
    uint32_t Row;       /* 矩阵行 */
    uint32_t Col;       /* 矩阵列 */
} DiscreteMathMatrix;

/*矩阵基本运算
 *1.矩阵:创建,销毁
 *2.矩阵'+,-'运算:(Matrix[M][N],Matrix1[M][N],Matrix2[M][N])
 *      Matrix[I][J] = Matrix1[I][J] (+,-) Matrix2[I][J]
 *3.矩阵'*'运算:(Matrix[M][N],Matrix1[M][K],Matrix2[K][N])
 *      Matrix[I][J] = SUM['+'](T=(0,K-1)) Matrix1[I][T] * Matrix2[T][J]
 *4.矩阵转置运算:(Matrix1[M][N],Matrix2[N][M])
 *      Matrix2[I][J] = Matrix1[J][I]
 *5.矩阵求逆运算:(Matrix[N][N])
 *      1.高斯消元法:
 *          1.将其与单位矩阵组合为一个增广矩阵(Extend[N][2N])=(Matrix|E)
 *          2.将增广矩阵从上往下行变换,前半部转为上三角矩阵
 *          3.将增广矩阵从下往上行变换,前半部转为对角矩阵
 *          4.将增广矩阵前半部转为单位矩阵
 *          5.后半部分为逆矩阵
 *      2.伴随矩阵法:
 *          1.求矩阵行列式的值|A|
 *          1.移除第I行与第J列后剩下的元素组合,并计算其行列式值M(I,J)
 *          2.  Matrix[J][I] = (-1)**(I + J) * M(I,J) / |A|
 *      3.LU分解法:
 *          1.将其分解为单位下三角矩阵L和上三角矩阵U(行消元即可)
 *          2.分别求其逆矩阵(行消元即可)
 *          3.按分解逆向顺序相乘获得逆矩阵
 *      4.全选主元高斯-约当消去法(高效):
 *          1.在每一个循环过程中,先寻找到主元,并将主元通过行变换(无需列变换)移动到矩阵的主对角线上
 *          2.然后将主元所在的行内的所有元素除以主元,使得主元化为1
 *          3.然后观察主元所在的列上的其他元素,将它们所在的行减去主元所在的行乘以一定的倍数
 *            使得主元所在的列内,除主元外的其他元素化为0,这样就使得主元所在的列化为了单位矩阵的形式
 *          5.在第下一轮循环的过程中,不考虑上一轮计算过程中主元所在的行和列内的元素
 *            在剩下的矩阵范围内寻找主元,然后(如果其不在主对角线上的话)将其移动到主对角线上
 *            并再次进行列的处理， 将列化为单位矩阵的形式
 *4.矩阵'&,|'运算:语义不变
 *5.矩阵布尔积:(Matrix[M][N],Matrix1[M][K],Matrix2[K][N])
 *      Matrix[I][J] = SUM['|'](T=(0,K-1)) Matrix1[I][T] & Matrix2[T][J]
 */
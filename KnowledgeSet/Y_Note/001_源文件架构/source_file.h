#ifndef SOURCE_FILE_H
#define SOURCE_FILE_H

///////////////////////////////////////////////////////////////////////////////
//将对应.c的依赖项迁移到此处///////////////////////////////////////////////////
//通过宏唯一载入,降低.c的复杂度////////////////////////////////////////////////
//隐藏不必要的依赖/////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#ifdef SOURCE_FILE_C
//所有对应.c的全部头依赖项
//#include <……>
#include <stdbool.h>
#include <stdarg.c>

//如果本层实现需要其他的依赖项
//直接调用时,应该此处采用宏进行重定向,为所有外部的引用重定向
#define XXX_xxx(……) xxx(……);
//当然,如果能保证此层仅作为桥阶层,为上层做简化时
//直接采用其直接调用也是可以的
#endif

///////////////////////////////////////////////////////////////////////////////
//数据集合采用,模板模式////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
typedef struct source_data_set {
    //为外界提供的数据集合
    //它应该是所有操作项参数(包括返回集)的并集
    //不管该项是否能为上层提供足够的服务
    //如此一来便形成了以数据为中心的高内聚实现
    struct {
        //所有实现都需要的参数
        //(非所有实现需要会降低空间重用率,但可以根据根据实际情况取舍)
        //一个数据集合,该部分一般初始化决定或者很少修改
        //例:实例编号等,通用配置集
    } common_arg;

    //一个数据集合,在其对应动作之前额外初始化下列参数集中一个
    //操作完毕后获取数据其数据,下一次直接覆盖初始化即可
    union {
        struct {
            
        } init_arg;
        struct {
            
        } deinit_arg;
        struct {
            
        } open_arg;
        struct {
            
        } close_arg;        
        struct {
            
        } other_arg;
    };
    //相对贴近实际而言,则无需额外考虑
    //并发访问的情况,否则需要加锁保护
} data_set;

//操作集合,如果需要接口封装时
void init(data_set* data);
void deinit(data_set* data);
void open(data_set* data);
void close(data_set* data);
void other(data_set* data);
#endif
